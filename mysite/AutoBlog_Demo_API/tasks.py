import os
import base64
import openai
import requests
from celery import app
from celery import shared_task
from openai import OpenAI
from io import BytesIO
from PIL import Image

client = OpenAI()

# Constants:
WORDPRESS_POST_URL = os.environ.get("WORDPRESS_URL") + "/wp-json/wp/v2/posts"
WORDPRESS_MEDIA_URL = os.environ.get("WORDPRESS_URL") + "/wp-json/wp/v2/media"
WORDPRESS_USERNAME = os.environ.get("WORDPRESS_USERNAME")
WORDPRESS_APPLICATION_PASSWORD = os.environ.get("WORDPRESS_APPLICATION_PASSWORD")
CREDENTIALS = WORDPRESS_USERNAME + ':' + WORDPRESS_APPLICATION_PASSWORD
TOKEN = base64.b64encode(CREDENTIALS.encode())
HEADER = {"Authorization":"Basic " + TOKEN.decode("utf-8")}

@shared_task
def generate_and_post_blog(title=''):
    """Generates and posts an image and blog to WordPress.

    Args:
        title (str, optional): The title of the blog that will be generated. 
        Defaults to ''.

    Returns:
        bool: Returns true
    """
    image_url = generate_blog_image(title=title)
    blog_content = write_blog(title=title)
    post_blog_and_image_to_wordpress(title=title, image_url=image_url, content=blog_content)
    return True


def write_blog(title=''):
    """Generates and returns a blog using gpt-3.5-turbo LLM. Each blog will have 5 
    subheadings and sections. Each element of the blog will be formatted using HTML. 
    

    Args:
        title (str, optional):  The title of the blog that will be generated. 
        Defaults to ''.

    Returns:
        str: The content of the generated blog formatted as an HTML article.
    """
    try:
        content = ""
        outline = write_blog_outline(title=title)
        sections = ["first", "second", "third", "fourth", "concluding"]

        for section in sections:
            blog_subheading = write_subheading(section=section, outline=outline)
            blog_section = write_section(section=section, subheading=blog_subheading, outline=outline)

            content += format_subheading_and_section(format_subheading(blog_subheading), format_section(blog_section))

    except openai.APIError as e:
        print("openai.APIError encountered when trying to generate blog")

    return f"<article style=\"font-family: Arial; display: flex; flex-direction: column; align-items: center;\">{content}</article>"

def post_blog_and_image_to_wordpress(title='', image_url='', content='',):
    """Posts generated blog and image to WordPress. After uploading the blog and 
    image to WordPress, the featured media of the blog is set to the uploaded image.

    Args:
        title (str, optional): Title of the generated blog. Defaults to ''.
        image_url (str, optional): URL of the generated Image. Defaults to ''.
        content (str, optional): The HTML formatted content of the generated blog. 
        Defaults to ''.
    """
    # POST blog to WordPress
    post_id = post_blog_to_wordpress(title=title, content=content)
    wordpress_current_post_url = WORDPRESS_POST_URL + '/' + str(post_id)

    # POST blog's header image to WordPress
    media_id = post_blog_image_to_wordpress(image_url=image_url)

    # Update blog's featured image
    update_blogs_featured_image(wordpress_current_post_url=wordpress_current_post_url, media_id=media_id)
    

def post_blog_to_wordpress(title='', content=''):
    """Posts generated blog to WordPress and returns the post_id of this post.

    Args:
        title (str, optional): Title of the generated blog. Defaults to ''.
        content (str, optional): The HTML formatted content of the generated blog.
        Defaults to ''.

    Returns:
        str: The post_id of the uploaded blog. WordPress automatically assigns this
        id when a post gets uploaded.
    """
    post = {
        "title" : title,
        "content" : content,
        "status" : "publish",
    }

    try:
        post_response = requests.post(WORDPRESS_POST_URL, headers=HEADER, json=post)
        post_id = post_response.json().get("id")
    except requests.exceptions.ConnectionError:
        return "Failed to POST blog content to WordPress"
    
    return post_id

def post_blog_image_to_wordpress(image_url=''):
    """Uploads generated image to WordPress and returns the media_id of this image.

    Args:
        image_url (str, optional): URL of the generated Image. Defaults to ''.

    Returns:
        str: The media_id of the uploaded image. WordPress automatically assigns this
        id when media gets uploaded.
    """
    try:
        # Get image data generated by Dalle3
        image_data = requests.get(image_url).content
        image = Image.open(BytesIO(image_data))

        # Reshape image and convert to webp format
        image = image.resize((600, 600))
        webp_image = BytesIO()
        image.save(webp_image, "webp")
        webp_image.seek(0)

        media = {
            'file': ('header_image.webp', webp_image, 'image/webp'),
            'status': 'publish'
        }
        
        media_response = requests.post(WORDPRESS_MEDIA_URL, headers=HEADER, files=media)
        media_id = media_response.json().get('id')
    except requests.exceptions.ConnectionError:
        return "Failed to POST blog's image to WordPress"
    
    return media_id

def update_blogs_featured_image(wordpress_current_post_url='', media_id=''):
    """Updates the featured media of the WordPress post at wordpress_current_post_url
    to the image with the id of media_id. 

    Args:
        wordpress_current_post_url (str, optional): URL of the newly created post on 
        WordPress. Defaults to ''.
        media_id (str, optional): The media_id of the uploaded image. Defaults to ''.

    Returns:
        str: "Failed to update blog's featured image" if changing featured media fails.
        Returns nothing otherwise.
    """
    featured_payload = {
        'featured_media': media_id
    }

    try:
        # Update blog's featured image
        requests.post(wordpress_current_post_url, headers=HEADER, json=featured_payload)
    except requests.exceptions.ConnectionError:
        return "Failed to update blog's featured image"

# HELPER METHODS
##############################################################################################################
#FORMAT BLOG CONTENT
def format_subheading(subheading):
    """Formats each subheading in the blog. Wraps subheading text in an h3 HTML tag

    Args:
        subheading (str): The text content of a given subheading 

    Returns:
        str: The formatted subheading wrapped in an h3 HTML tag
    """
    subheading_html = f"<h3 style=\"text-align: center;\">{subheading}</h3>"    
    return subheading_html

def format_section(section):
    """Formats each section in the blog. Wraps section text in an p HTML tag

    Args:
        section (str): The text content of a given section 

    Returns:
        str: The formatted section wrapped in an p HTML tag
    """
    section_html = f"<p> &emsp; {section}</p>"
    return section_html

def format_subheading_and_section(subheading, section):
    """_summary_

    Args:
        subheading (str): The formatted HTML of a given subheading
        section (str): The formatted HTML of a given section

    Returns:
        str: The formatted section of a blog wrapped in a section HTML tag
    """
    subheading_and_section_html = f"<section style=\"display: flex; flex-direction: column; align-items: center;\">{subheading} {section}</section> "
    return subheading_and_section_html

# CALLS TO OPENAI API
def generate_blog_image(title=''):
    """Generates an image based on a blog's title using dalle3 and returns the URL
    of this image.

    Args:
        title (str, optional): The title of a blog. Defaults to ''.

    Returns:
        str: The URL of the generated image.
    """
    response = client.images.generate(
        model="dall-e-3",
        prompt=f"Generate a header image for a blog titled: {title}. Do not include text in the image.",
        size="1024x1024",
        quality="standard",
    )

    image_url = response.data[0].url
    return image_url

def write_blog_outline(title=''):
    """Generates and returns a blog outline for a blog titled title. 

    Args:
        title (str, optional): The title of a blog used for generating an outline.
        Defaults to ''.

    Returns:
        str: The blog outline generated by the gpt-3.5-turbo LLM.
    """
    completion = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{'role':'user', "content": f"Please ignore all previous instructions. You are an expert copywriter who creates blog outlines for a living. You have a friendly tone of voice. You have a conversational writing style. Create a long form content outline in english for the blog post titled {title}. The content outline should include a minimum of 5 subheadings and headings. The outline should be extensive and should cover the entire topic. Create detailed subheadings that are engaging. Do not write the blog post. Please only write the outline of the blog post. Please do not number the headings. Please add newline space between headings and subheadings. Do not self reference. Do not explain what you are doing"}]
    )
    outline = completion.choices[0].message.content
    return outline

def write_subheading(section='', outline=''):
    """Generates and returns a given subheading for the blog. section will
    be one of the following: "first", "second", "third", "fourth", or "concluding". 

    Args:
        section (str, optional): The section of the blog that the current subheading
        is being generated for. Defaults to ''.
        outline (str, optional): The outline of the blog. Used for providing context.
        Defaults to ''.

    Returns:
        str: The generated subheading for a given section of a blog.
    """
    completion = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{'role':'user', "content": f"Please ignore all previous instructions. You are an expert copywriter who creates blog subheadings for a living. You have a friendly tone of voice. You have a conversational writing style. Using this blog outline: {outline}, write the {section} subheading for this blog. Make sure this subheading is SEO optimized and keep this subheading to at most 10 words. EXCLUDE any numbers of dashes from this subheading."}]
    )
    generated_subheading = completion.choices[0].message.content
    return generated_subheading

def write_section(section='', subheading='', outline=''):
    """Generates and returns a given paragraph section for the blog. section will
    be one of the following: "first", "second", "third", "fourth", or "concluding".

    Args:
        section (str, optional): The section of the blog that the current subheading
        is being generated for. Defaults to ''.
        subheading (str, optional): The subheading of the current section. Used for 
        providing context. Defaults to ''.
        outline (str, optional): The outline of the blog. Used for providing context.
        Defaults to ''.

    Returns:
        str: The generated paragraph for a given section of a blog. 
    """
    completion = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{'role':'user', "content": f"Please ignore all previous instructions. You are an expert copywriter who creates blog paragraphs for a living. You have a friendly tone of voice. You have a conversational writing style. Using this blog outline: {outline} and the subheading {subheading}, write the {section} content section for this blog. Do NOT include the name of this subheading in this section. Keep this section between 100 and 150 words. Also use language that an 8th grader can understand. Make sure it is SEO optimized."}]
    )
    generated_section = completion.choices[0].message.content
    return generated_section